%%%%%%%%%%%%%%% LaTeX Compiler: XeLaTeX %%%%%%%%%%%%%%%

% License for LaTeX Configuration File

% This LaTeX configuration file is created by Lin, Xuanyu, HKUST, and is provided under the terms of the MIT License. You are free to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of this configuration file, subject to the following conditions:

% 1. The above copyright notice and this license notice shall be included in all copies or substantial portions of the configuration file.

% 2. The configuration file is provided "as is", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the configuration file or the use or other dealings in the configuration file.

% By using this configuration file, you agree to the terms and conditions of this license. If you do not agree to these terms and conditions, you must not use the configuration file.

\documentclass[10pt]{article}
% Text setting
% \usepackage{newtxtext}
\usepackage{setspace}
\usepackage[dvipsnames,svgnames]{xcolor}
\usepackage{comment}
% Chinese characters setup
\usepackage{fontspec}
\usepackage{xeCJK}
\setCJKmainfont{SimSun}
% Dealing with special characters
\usepackage[utf8]{inputenc}
% \usepackage[T1]{fontenc} % Conflict with fontspec & xeCJK
\usepackage{pifont}
% Mathematical formula typesetting
\usepackage{unicode-math}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{mathrsfs}
\setmathfont{Latin Modern Math}
% \usepackage{amssymb} % Contained in package unicode-math
% Jump (Math) \llbracket & \rrbracket
\usepackage{stmaryrd}
% Chemical formulas and equations
\usepackage[version=4]{mhchem}
% Graphics
\usepackage{graphicx}
\graphicspath{ {./images/} }
\usepackage[export]{adjustbox}
% Tables, enumeration
\usepackage{multirow}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{enumitem}
% Adjust the position
\usepackage{float}
% Frames, reference
\usepackage{framed}
\usepackage[strict]{changepage}
\usepackage{hyperref}
\hypersetup{
	colorlinks=true,
	linkcolor=black,
	filecolor=magenta,      
	urlcolor=blue,
}
% Page & paragraph settings
\usepackage{fancyhdr}
\usepackage{geometry}
\geometry{left=1.5cm, right=1.5cm, top=2cm, bottom=2cm}
\usepackage{indentfirst}
\setlength{\parindent}{2em}
\setlength{\parskip}{0em}
% Algorithm & coding environment
\usepackage[ruled,vlined]{algorithm2e}
\usepackage[framemethod=TikZ]{mdframed}
\usepackage{listings}
% New command
\newcommand\course{COMP 3711}  
\newcommand\coursetitle{Design and Analysis of Algorithms}
\newcommand\semester{Fall 2023}
\renewcommand{\labelenumi}{\alph{enumi}}
\newcommand{\Z}{\mathbb Z}
\newcommand{\R}{\mathbb R}
\newcommand{\Q}{\mathbb Q}
\newcommand{\NN}{\mathbb N}
\newcommand{\dd}{\mathrm{d}}
\DeclareMathOperator{\Mod}{Mod}
\renewcommand\lstlistingname{Algorithm}
\renewcommand\lstlistlistingname{Algorithms}
\def\lstlistingautorefname{Alg.}

%%%%%%%%%%%%%%% Page Setup %%%%%%%%%%%%%%%

\pagestyle{fancy}
\headheight 35pt
\lhead{\course\ \coursetitle\ \semester}
\rhead{\includegraphics[width=2.5cm]{logo-hkust.png}}
\lfoot{}
\pagenumbering{arabic}
\cfoot{}
\rfoot{\small\thepage}
\headsep 1.2em

%%%%%%%%%%%%%%% Boxframe Setup %%%%%%%%%%%%%%%

\definecolor{blueshade}{rgb}{0.95,0.95,1} % Horizontal Line: DarkBlue
\definecolor{greenshade}{rgb}{0.90,0.99,0.91} % Horizontal Line: Green
\definecolor{redshade}{rgb}{1.00,0.90,0.90}% Horizontal Line: LightCoral
\definecolor{brownshade}{rgb}{0.99,0.97,0.93} % Horizontal Line: BurlyWood

\newenvironment{formal}[2]{%
	\def\FrameCommand{%
		\hspace{1pt}%
		{\color{#1}\vrule width 2pt}%
		{\color{#2}\vrule width 4pt}%
		\colorbox{#2}%
	}%
	\MakeFramed{\advance\hsize-\width\FrameRestore}%
	\noindent\hspace{-4.55pt}% Disable indenting first paragraph
	\begin{adjustwidth}{}{7pt}%
		\vspace{2pt}\vspace{2pt}%
	}
	{%
		\vspace{2pt}\end{adjustwidth}\endMakeFramed%
}

%%%%%%%%%%%%%%% Problem Environment Setup %%%%%%%%%%%%%%%

\mdfdefinestyle{problemstyle}{
	linecolor=black,linewidth=1pt,
	frametitlerule=true,
	frametitlebackgroundcolor=gray!20,
	roundcorner=10pt,
	innertopmargin=\topskip,
	frametitlealignment=\hspace{0em},
}

\mdfsetup{skipabove=\topskip,skipbelow=\topskip}
\mdtheorem[style=problemstyle]{Problem}{Problem}
\newenvironment{Solution}{\textbf{Solution.}}

%%%%%%%%%%%%%%% Coding Environment S6etup %%%%%%%%%%%%%%%

\lstset{
	basicstyle=\tt,
	% Line number
	numbers=left,
	rulesepcolor=\color{red!20!green!20!blue!20},
	escapeinside=``,
	xleftmargin=2em,xrightmargin=2em, aboveskip=1em,
	% Background frame
	framexleftmargin=1.5mm,
	frame=shadowbox,
	% Background color
	backgroundcolor=\color[RGB]{252,236,227},
	% Style
	keywordstyle=\color{blue}\bfseries,
	identifierstyle=\bf,
	numberstyle=\color[RGB]{0,192,192},
	commentstyle=\it\color[RGB]{0,153,51},
	stringstyle=\rmfamily\slshape\color[RGB]{128,0,0},
	% Show space
	showstringspaces=false
}

%%%%%%%%%%%%%%% Document Begins %%%%%%%%%%%%%%%

\begin{document}
	
%%%%%%%%%%%%%%% Title Page %%%%%%%%%%%%%%%

\begin{titlepage}
	\begin{center}
		\vspace*{3cm}
		
		\Huge
		\hrulefill
		\vspace{1cm}
		
		\huge
		\textbf{COMP 3711 Course Notes\\}
		\vspace{1cm}
		\textbf{Design and Analysis of Algorithms}
		\vspace{1cm}
		
		\hrulefill
		
		\vspace{1.5cm}
		\Large

		\textbf{LIN, Xuanyu}
		
		\vfill
		
		$\mathscr{ALGORITHMS}$
		
		\vspace{1cm}
		
		\course \ Design and Analysis of Algorithms
		
		\vspace{1cm}
		
		\includegraphics[width=0.4\textwidth]{logo-hkust.png}
		\\
		
		\Large
		
		\today
		
	\end{center}
\end{titlepage}

%%%%%%%%%%%%%%% Article Begins %%%%%%%%%%%%%%%

\begin{comment}

\begin{abstract}
	Abstract Abstract Abstract Abstract Abstract Abstract Abstract Abstract Abstract Abstract Abstract Abstract Abstract Abstract Abstract Abstract Abstract Abstract Abstract Abstract Abstract Abstract Abstract Abstract Abstract Abstract Abstract Abstract Abstract Abstract Abstract Abstract Abstract
\end{abstract}

\tableofcontents

\begin{center}
	\section*{\LARGE Title}
\end{center}

\section{Section 1}

This is a link to \href{https://www.google.com}{Google}.

$$
\vec{\nabla} \cdot \vec{E}=\frac{1}{\epsilon_{0}} \cdot \rho
$$

\begin{formal}{DarkBlue}{blueshade}
	\textbf{Theorem 1.1} 这是一段中文。\hyperref[ref1]{[1]}
	
	$$
	\vec{\nabla} \cdot \vec{E}=\frac{1}{\epsilon_{0}} \cdot \rho
	$$
	
	\noindent This is an English sentence.
\end{formal}


\begin{center}
	\begin{tabular}{|c|c|c|}
		\hline
		\multirow{2}{*}{A} & B & C \\
		\cline{2-3}
		& D & E \\
		\hline
	\end{tabular}
\end{center}

\begin{algorithm}
	\SetAlgoLined
	\KwIn{$a, b$}
	\KwOut{$c$}
	$c = a + b$\;
	\Return{$c$}\;
	\caption{Addition}
\end{algorithm}

\begin{Problem}[Title]
	
	\lstset{language=Python}
	\begin{lstlisting}[tabsize=4]
print("Hello World!")
	\end{lstlisting}

\end{Problem}

\begin{Solution}
	
	Text
	
\end{Solution}

\section{References}

\label{ref1}

[1] Google \href{https://www.google.com}{https://www.google.com}

\end{comment}

\tableofcontents

\newpage

\section{Asymptotic Notation}

\begin{formal}{DarkBlue}{blueshade}
	
	\noindent \textbf{Upper Bounds} $T(n) = O(f(n))$
	
	if exist constants $c > 0$ and $n_0 \geq 0$ such that for all $n \geq n_0$, $T(n) \leq c \cdot f(n)$.
	
	\noindent \textbf{Lower Bounds} $T(n) = \Omega(f(n))$
	
	if exist constants $c > 0$ and $n_0 \geq 0$ such that for all $n \geq n_0$, $T(n) \geq c \cdot f(n)$.
	
	\noindent \textbf{Tight Bounds} $T(n) = \Theta(f(n))$
	
	if $T(n) = O(f(n))$ and $T(n) = \Omega(f(n))$.
	
	\noindent \textbf{Note:} Here "=" means "is", not equal.
	
\end{formal}

\section{Introduction - The Sorting Problem}

\subsection{Selection Sort}

\begin{algorithm}
	\SetAlgoLined
	\KwIn{An array $A[1 ... n]$ of elements}
	\KwOut{Array $A[1 ... n]$ of elements in sorted order (asending)}
	\For{$i \gets 1$ to $n-1$}{
		\For{$j \gets i+1$ to $n$}{
			\If{$A[i]>A[j]$}{
				swap $A[i]$ and $A[j]$
			}
		}
	}
	\caption{Selection Sort}
\end{algorithm}

Running Time: $\frac{n(n-1)}{2}$

Best-Case = Worst-Case: $T(n) = \Theta(\frac{n(n-1)}{2}) = \Theta(n^2)$

\subsection{Insertion Sort}

\begin{algorithm}
	\SetAlgoLined
	\KwIn{An array $A[1 ... n]$ of elements}
	\KwOut{Array $A[1 ... n]$ of elements in sorted order (asending)}
	\For{$i \gets 2$ to $n$}{
		$j \gets i-1$
		\While{$j \geq 1$ and $A[j] > A[j+1]$}{
			swap $A[j]$ and $A[j+1]$
		}
		$j \gets j-1$
	}
	\caption{Insertion Sort}
\end{algorithm}

Running Time: Depends on the input array, ranges between $(n-1)$ and $\frac{n(n-1)}{2}$

Best-Case: $T(n) = n-1 = \Theta(n)$ (Useless)

Worst-Case: $T(n) = \Theta(\frac{n(n-1)}{2}) = \Theta(n^2)$ (Commonly-Used)

Average-Case: $T(n) = \Theta(\sum_{i=2}^n \frac{i-1}{2}) = \Theta(\frac{n(n-1)}{4}) = \Theta(n^2)$ (Sometimes Used)

\subsection{Wild-Guess Sort}

\begin{algorithm}
	\SetAlgoLined
	\KwIn{An array $A[1 ... n]$ of elements}
	\KwOut{Array $A[1 ... n]$ of elements in sorted order (asending)}
	$\pi \gets [4,7,1,3,8,11,5,...]$\ \ Create random permutation
	Check if $A[\pi[i]] \leq A[\pi[i+1]]$ for all $i = 1,2,...,n-1$
	If yes, output A according to $\pi$ and terminate
	else $Insertion-Sort(A)$
	\caption{Wild-Guess Sort}
\end{algorithm}

Running Time: Depends on the random generation, could be faster than the insertion sort.

\subsection{Worst-Case Analysis}

The algorithm’s worst case running time is $O(f(n)) \implies $ On all inputs of (large) size $n$, the running time of the algorithm is $\leq c \cdot f(n)$.

The algorithm’s worst case running time is $\Omega (f(n)) \implies $ There exists at least one input of (large) size $n$ for which the running time of the algorithm is  $\geq c \cdot f(n)$.

Thus, Insertion sort runs in $\Theta (n^2)$ time.

\begin{formal}{DarkBlue}{blueshade}
	
	\textbf{Notice}
	
	Selection sort, insertion sort, and wild-guess sort all have worst-case running time $\Theta (n^2)$. How to distinguish between them?
	
	$\bullet$ Closer examination of hidden constants
	
	$\bullet$ Careful analysis of typical expected inputs
	
	$\bullet$ Other factors such as cache efficiency, parallelization are important
	
	$\bullet$ Empirical comparison
	
\end{formal}

\begin{formal}{DarkGreen}{greenshade}

	\textbf{Stirling's Formula}
	
	Prove that $\log (n!) = \Theta (n \log n)$
	
	First $\log (n!) = O (n \log n)$ since:
	
	$$
	\log (n!) = \sum_{i=1}^n \log i \leq n \times \log n = O (n \log n)
	$$

	Second $\log (n!) = \Omega (n \log n)$ since:
	
	$$
	\log (n!) = \sum_{i=1}^n \log i \geq \sum_{i=n/2}^n \log i \geq n/2 \times \log n/2 = n/2 (\log n - \log 2) = \Omega (n \log n)
	$$
	
	Thus, $\log (n!) = \Theta (n \log n)$

\end{formal}

\newpage

\section{Divide \& Conquer}

\textbf{Main idea of D \& C:} Solve a problem of size $n$ by breaking it into one or more smaller problems of size less than $n$. Solve the smaller problems recursively and combine their solutions, to solve the large problem.


\subsection{Binary Search}

\begin{formal}{Brown}{brownshade}
	
	\textbf{Example: Binary Search}
	
	\textbf{Input:} A sorted array $A[1,...,n]$, and an element $x$
	
	\textbf{Output:} Return the position of $x$, if it is in $A$; otherwise output nil
	
	\textbf{Idea of the binary search:} Set $q \gets$ middle of the array. If $x = A[q]$, return $q$. If $x < A[q]$, search $A[1,...,q-1]$, else search $A[q+1,...,n]$.
	
\end{formal}

\begin{algorithm}
	\SetAlgoLined
	\KwIn{Array $A[1 ... n]$ of elements in sorted order}
	\SetKwFunction{Func}{BinarySearch}
	\Func{$A[], p, r, x$}($p, r$ being the left \& right iteration, $x$ being the element being searched){
		
		\If{$p > r$}{
			\Return{nil}
		}
		$q \gets [(p+r)/2]$
		
		\If{$x = A[q]$}{
			\Return{$q$}
		}
		\If{$x < A[q]$}{
			\Func{$A[], p, q-1, x$}
		}
		\Else{
			\Func{$A[], q+1, r, x$}
		}
	}
	\caption{Binary Search}
\end{algorithm}

Recurrence of the algorithm, supposing $T(n)$ being the number of the comparisons needed for $n$ elements:

\noindent $T(n) = T(\frac{n}{2}) + 2$ if $n > 1$, with $T(1) = 2$.

$\implies T(n) = 2\log_2 n + 2 \implies O(\log n)$ algorithm

\begin{formal}{Brown}{brownshade}
	
	\textbf{Example: Binary Search in Rotated Array}
	
	Suppose you are given a sorted array $A$ of $n$ distinct numbers that 
	has been rotated $k$ steps, for some unknown integer $k$ between 1 and $n-1$. That is, $A[1 ... k]$ is sorted in increasing order, and $A[k+1 ... n]$ is also sorted in increasing order, and $A[n] < A[1]$.
	
	Design an $O(\log n)$-time algorithm that for any given x, 
	finds x in the rotated sorted array, or reports that it does not 
	exist.
	
	\noindent \textbf{Algorithm:}
	
	First conduct a $O(\log n)$ algorithm to find the value of $k$, then search for the target value in either the first part or the second part.
	
	$Find-x(A, x)$
	
	$k \leftarrow Find-k(A, 1, n)$ (First find $k$)
	
	$if\ x \geq A[1]\ then\ return\ BinarySearch(A, 1, k, x)$
	
	$Else\ return\ BinarySearch(A, k+1, n, x)$
	
\end{formal}

\newpage

\begin{formal}{Brown}{brownshade}
	
	\textbf{Example: Finding the last 0}
	
	You are given an array $A[1 ... n]$ that contains a sequence of 0 
	followed by a sequence of 1 (e.g., 0001111111). $A$ contains $k$ 0(s) ($k>0$ and $k<<n$) and at least one 1.
	
	Design an $O(\log k)$-time algorithm that finds the position $k$ of the last 0.

	\noindent \textbf{Algorithm:}
	
	$i\leftarrow1$
	
	$while\ A[i]=0$
	
	\quad \quad $i\leftarrow2i$
	
	$find-k(A[i/2 ... i])$

\end{formal}

\subsection{Merge Sort}

\textbf{Principle of the Merge Sort:}

$\bullet$ Divide array into two halves.

$\bullet$ Recursively sort each half.

$\bullet$ Merge two halves to make sorted whole.

\begin{algorithm}
	\SetAlgoLined
	\SetKwFunction{MergeSort}{MergeSort}
	\SetKwFunction{Merge}{Merge}
	\MergeSort{$A, p, r$}($p, r$ being the left \& right side of the array to be sorted){
		
		\If{$p = r$}{
			\Return
		}
		$q \gets [(p+r)/2]$
		
		\MergeSort{$A, p, q$}
		
		\MergeSort{$A, q+1, r$}
		
		\Merge{$A, p, q, r$}
		
		\underline{First Call:} \MergeSort{$A, 1, n$}
	}
	\caption{Merge Sort}
\end{algorithm}

\begin{algorithm}
	\SetAlgoLined
	\KwIn{Two Arrays $L\gets A[p ... q]$ and $R\gets A[q+1 ... r]$ of elements in sorted order}
	\SetKwFunction{Merge}{Merge}
	\Merge{$A, p, q, r$}{
		
		Append $\infty$ at the end of $L$ and $R$
		
		$i\gets 1,\ j\gets 1$
		
		\For{$k \gets p$ to $r$}{
		
			\If{$L[i] \leq R[j]$}{
				
				$A[k] \gets L[i]$
				
				$i \gets i + 1$

			}
		
			\Else{
			
				$A[k] \gets R[j]$
				
				$j \gets j + 1$
		
			}
			
		}

	}
	\caption{Merge}
\end{algorithm}

Let $T(n)$ be the running time of the algorithm on an array of size $n$.

\noindent \textbf{Merge Sort Recurrence:}
$$
T(n) \leq T(\lfloor n/2 \rfloor) + T(\lceil n/2 \rceil) + O(n), \quad n>1, \quad T(1) = O(1)
$$
\textbf{Simplification:}
$$
\implies T(n) = 2T(n/2) + n, \quad n>1, \quad T(1) = 1
$$
\textbf{Result:}
$$
T(n) = n\log_2 n + n = O(n\log n)
$$

\newpage

\subsection{Inversion Counting}

\textbf{Definition of the Inversion Numbers:} Given array $A[1 ... n]$, two elements $A[i]$ and $A[j]$ are inverted if $i < j$ but $A[i] > A[j]$. The inversion number of $A$ is the number of inverted pairs.

\begin{formal}{DarkBlue}{blueshade}
	
	\textbf{Theorem:}

	The number of swaps used by Insertion Sort = Inversion Number (Proved by induction on the size of the array)
	
	\noindent \textbf{Algorithm to Compute Inversion Number:}
	
	Algorithm 1: Check all $\Theta(n^2)$ pairs.
	
	Algorithm 2: Run Insertion Sort and count the number of swaps – Also $\Theta(n^2)$ time.
	
	Algorithm 3: Divide and Conquer
	
\end{formal}

\subsubsection{Counting Inversions: Divide-and-Conquer}

\textbf{Principle of the Algorithm:}

$\bullet$ Divide: divide array into two halves

$\bullet$ Conquer: recursively count inversions in each half

$\bullet$ Conbine: count inversions where $a_i$ and $a_j$ are in different halves, and return sum of three quantities

Inversion counting during the combine step is very similar to the Merge Algorithm (Algorithm 6), by counting the sum of each inversion number of the right array (indicated by $I[j]$) comparing to the left array.

\begin{algorithm}
	\SetAlgoLined
	\KwIn{Two Arrays $L\gets A[p ... q]$ and $R\gets A[q+1 ... r]$ of elements in sorted order}
	\SetKwFunction{Count}{Count}
	\Count{$A, p, q, r$}{
		
		$i\gets 1,\ j\gets 1,\ c\gets 0$
		
		\While{$(i \leq q-p+1) \&\& (j \leq r-q)$}{
			
			\If{$L[i] \leq R[j]$}{
				
				$i \gets i+1$
				
			}
			
			\Else{
				
				$I[j] = q-p-i+2$
				
				$c \gets c+I[j]$
				
				$j \gets j+1$
				
			}
			
		}
		
	}
	\caption{Inversion Count during Combination}
\end{algorithm}

The time-complexity of the algorithm is $\Theta(n\log n)$, same as the Merge Sort.

\subsubsection{Implementation of the Algorithm}

\begin{algorithm}
	\SetAlgoLined
	\SetKwFunction{Sort}{Sort-and-Count}
	\SetKwFunction{Merge}{Merge-and-Count}
	\Sort{$A, p, r$}{
		
		\If{$p = r$}{
			\Return{0}
		}
		$q \gets \lfloor(p+r)/2\rfloor$
		
		$c_1 \gets$ \Sort{$A, p, q$}
		
		$c_2 \gets$ \Sort{$A, q+1, r$}
		
		$c_3 \gets$ \Merge{$A, p, q, r$}
		
		\Return{$c_1 + c_2 + c_3$}
		
		\underline{First Call:} \Sort{$A, 1, n$}
	}
	\caption{Main Algorithm}
\end{algorithm}

\begin{algorithm}
	\SetAlgoLined
	\KwIn{Two Arrays $L\gets A[p ... q]$ and $R\gets A[q+1 ... r]$ of elements in sorted order}
	\SetKwFunction{Merge}{Merge-and-Count}
	\Merge{$A, p, q, r$}{
		
		Append $\infty$ at the end of $L$ and $R$
		
		$i\gets 1,\ j\gets 1, c\gets 0$
		
		\For{$k \gets p$ to $r$}{
			
			\If{$L[i] \leq R[j]$}{
				
				$A[k] \gets L[i]$
				
				$i \gets i + 1$
				
			}
			
			\Else{
				
				$A[k] \gets R[j]$
				
				$j \gets j + 1$
				
				$c \gets c+q-p-i+2$
				
			}
			
		}
	
		\Return{$c$}
		
	}
	\caption{Merge-and-Count}
\end{algorithm}

\subsection{Basic Summary of D\&C: Problem Size \& Number of Problems}

\textbf{Observations of D\&C in Logarithmic Patterns:}

$\bullet$ Break up problem of size $n$ into $p$ parts of size $n/q$.

$\bullet$ Solve parts recursively and combine solutions into overall solution.

$\bullet$ At level $i$, we break $i$ times and we have $p^i$ problems of size $n/q^i$.

$\bullet$ When we cannot break up any more, usually when the problem size 
becomes 1. Usually $i \approx \log_q n$.

\begin{formal}{DarkGreen}{greenshade}

The number of problems at (bottom) level $\log_q n$ is $p^i = p^{\log_q n} = n^{\log_q p}$.

\end{formal}

\vspace{1em}

\textbf{Observations of D\&C in Non-Logarithmic Patterns:}

$\bullet$ Break up problem of size $n$ into $p(\leq 2)$ parts of size $n-q$. (e.g. $q=1$ for Hanoi Problem)

$\bullet$ Assume that $q=1$

$\bullet$ At level i, we break $i$ times and we have $p^i$ problems of size $n-i$.

$\bullet$ If we stop when the problem size becomes 1, then $n-i=1 \implies i=n-1$.

\begin{formal}{DarkGreen}{greenshade}

The number of problems at (bottom) level $n-1$ is: $p^i = p^{n-1}$.

\end{formal}

\subsection{Maximum Contiguous Subarray}

\begin{formal}{Brown}{brownshade}
	
	\textbf{Example: The Maximum Subarray Problem}
	
	\textbf{Input:} An array of numbers $A[1,...,n]$, both positive and negative
	
	\textbf{Output:} Find the maximum $V(i, j)$, where $V(i, j) = \sum_{k=i}^j A[k]$
	
\end{formal}

\subsubsection*{Brute-Force Algorithm}

\textbf{Idea:} Calculate the value of $V(i, j)$ for each pair $i\leq j$ and return the maximum value.

Requires three nested for-loop, time complexity: $\Theta(n^3)$.

\subsubsection*{A Data-Reuse Algorithm}

\textbf{Idea:} $V(i, j) = V(i, j-1) + A[j]$

Requires two nested for-loop, time complexity: $\Theta(n^2)$.

\newpage

\subsubsection{A D\&C Algorithm}

\textbf{Idea:} Cut the array into two halves, all subarrays can be classified into three cases: entirely in the first/second half, or crosses the cut.

\textbf{Compare with the merge sort:} Whole algorithm will run in $\Theta(n\log n)$ time if the cross-cut can be solved in $O(n)$ time.

\begin{algorithm}
	\SetAlgoLined
	\SetKwFunction{MaxSubArray}{MaxSubArray}
	\MaxSubArray{$A, p, r$}{
		
		\If{$p = r$}{
			\Return{$A[p]$}
		}
		$q \gets \lfloor(p+r)/2\rfloor$
		
		$M_1 \gets$ \MaxSubArray{$A, p, q$}
		
		$M_2 \gets$ \MaxSubArray{$A, q+1, r$}
		
		$L_m, R_m \gets -\infty$
		
		$V \gets 0$
		
		\For{$i \gets q$ to $p$}{
		
			$V \gets V+A[i]$
			
			\If{$V>L_m$}{
			
				$L_m \gets V$
			
			}
		
		}
	
		$V \gets 0$
		
		\For{$i \gets q+1$ to $r$}{
			
			$V \gets V+A[i]$
			
			\If{$V>R_m$}{
				
				$R_m \gets V$
				
			}
			
		}
		
		\Return{$\max(M_1, M_2, L_m+R_m)$}
		
		\underline{First Call:} \MaxSubArray{$A, 1, n$}
	}
	\caption{Maximum Subarray}
\end{algorithm}

\textbf{Recurrence:} $T(n) = 2T(n/2)+n \implies T(n) = \Theta(n\log n)$

\subsubsection{Kadane's Algorithm}

\textbf{Idea:} Based on the principles of \textbf{Dynamic Programming}. Let $V[i]$ be the (local) maximum sub-array that ends at $A[i]$, then we let:

$\bullet V[1] = A[1]$

$\bullet V[i] = \max(A[i], A[i] + V[i-1])$

The maximum of $V[i]$, namely $V_{max}$ is the maximum continuous subarray found so far.

\begin{algorithm}
	\SetAlgoLined
	
	$V_{max} \gets -\infty; V \gets 0; \text{start} \gets 1; \text{end} \gets 1; \text{temp} \gets 1$ (Note: start \& end specify the maximum sub-array)
		
	\For{$i\gets 1$ to $n$}{
	
	$V\gets V+A[i]$
	
	\If(// Implies $V[i-1]$ is negative, restart from the current position){$V < A[i]$}{
		
		$V\gets A[i]; \text{temp}\gets i$
		
		}

	\If(// Found a max sum, update start and end){$V > V+{max}$}{
	
		$V_{max}\gets V; \text{start}\gets \text{temp}; \text{end}\gets i$

		}

	}
	
	\caption{Kadane's Algorithm}
\end{algorithm}

\begin{formal}{Brown}{brownshade}
	
	\textbf{Example: Maximizing Stock Profits}
	
	You are presented with an array $p[1\dots n]$ where $p[i]$ is the price of the stock on day $i$.
	
	Design an divide-and-conquer algorithm that finds a strategy to make as much money as possible, i.e., it finds a pair $i, j$ with $1\leq i\leq j\leq n$ such that $p[j]-p[i]$ is maximized over all possible such pairs. Note that you are only allowed to buy the stock once and then sell it later.

\end{formal}

\textbf{Idea 1: Divide and Conquer}

$\bullet$ Cut the array into two halves.

$\bullet$ All $i, j$ solutions can be classified into three cases: both $i, j$ are entirely in the first(second) half, or $i$ is in the left half while $j$ is in the right half.

$\bullet$ Maximizing a Case 3 result $p[j]-p[i]$ means finding the smallest value in the first half and the largest in the second half.

\textbf{Time Complexity:} $T(n) = 2T(n/2) + n \implies T(n) = \Theta(n\log n)$

\vspace*{1em}

\textbf{Idea 2: Kadane's Algorithm}

$\bullet$ Create a \textbf{Profit} array with $Profit[i]=Price[i+1]-Price[i]$.

$\bullet$ Perform the Kadane's Algorithm.

\textbf{Time Complexity:} $O(n)$

\subsection{Integer and Matrix Multiplication}

\subsubsection{A Simple D\&C Algorithm for Integer Multiplication}

\textbf{Goal:} Given two $n$-bit binary integers $a$ and $b$, compute: $a\cdot b$.

\textbf{Idea:} Multiplication by $2^k$ can be done in one time unit by a left shift of $k$ bits.

$\bullet$ Rewrite the two numbers as $a = 2^{n/2} a_1 + a_0$, $b = 2^{n/2} b_1 + b_0$.

$\bullet$ The product becomes: $a\cdot b = (2^{n/2} a_1 + a_0)(2^{n/2} b_1 + b_0) = 2^n a_1 b_1 + 2^{n/2} (a_1 b_0 + a_0 b_1) + a_0 b_0$

$\bullet$ The new computation requires 4 products of integers, each with $n/2$ bits.

$\bullet$ Apply D\&C by splitting a problem of size $n$, to 4 problems of size $n/2$.

\begin{algorithm}
	\SetAlgoLined
	\SetKwFunction{Multiply}{Multiply}
	\Multiply{$A, B$}{
		
		$n\gets$ size of $A$
		
		\If{$n = 1$}{\Return{$A[1]\cdot B[1]$}}
		
		$mid \gets \lfloor n/2 \rfloor$
		
		$U \gets$ \Multiply($A[mid+1..n], B[mid+1..n]$) // $a_1b_1$
		
		$V \gets$ \Multiply($A[mid+1..n], B[1..mid]$) // $a_1b_0$
		
		$W \gets$ \Multiply($A[1..mid], B[mid+1..n]$) // $a_0b_1$
		
		$Z \gets$ \Multiply($A[1..mid], B[1..mid]$) // $a_0b_0$
		
		$M[1..2n]\gets 0$
		
		$M[1..n]\gets Z$ // $a_0b_0$
		
		$M[mid+1..]\gets M[mid+1..] \oplus V \oplus W$ // $+[(a_1b_0+a_0b_1)\ll\text{(left shift) } n/2]$
		
		$M[2mid+1..]\gets M[2mid+1..] \oplus U$ // $+[a_1b_1\ll n]$
		
		\Return{$M$}
		
	}
	\caption{Binary Multiplication}
\end{algorithm}

\textbf{Time Complexity:} $T(n) = 4T(n/2) + n\implies T(n) = \Theta(n^2)$

\newpage

\subsubsection{Karatsuba Multiplication}

\textbf{Goal:} Given two $n$-bit binary integers $a$ and $b$, compute: $a\cdot b$.

\textbf{Idea:}

$\bullet$ We've seen that $ab = a_1b_1 2^n + (a_1b_0+a_0b_1) 2^{n/2} + a_0b_0$, so we only need the result of $a_1b_0+a_0b_1$.

$\bullet$ Note that $a_1b_0+a_0b_1 = (a_1+a_0)(b_1+b_0) - a_1b_1 - a_0b_0$, thus only requires performing 3 multiplications of size $n/2$.

\begin{algorithm}
	\SetAlgoLined
	\SetKwFunction{Multiply}{Multiply}
	\Multiply{$A, B$}{
		
		$n\gets$ size of $A$
		
		\If{$n = 1$}{\Return{$A[1]\cdot B[1]$}}
		
		$mid \gets \lfloor n/2 \rfloor$
		
		$U \gets$ \Multiply($A[mid+1..n], B[mid+1..n]$) // $a_1b_1$
		
		$Z \gets$ \Multiply($A[1..mid], B[1..mid]$) // $a_0b_0$
		
		$A'\gets A[mid+1..n] \oplus A[1..mid]$ // $a_1+a_0$
		
		$B'\gets B[mid+1..n] \oplus B[1..mid]$ // $b_1+b_0$
		
		$Y \gets$ \Multiply($A', B'$) // $(a_1+a_0)(b_!+b_0)$
		
		$M[1..2n]\gets 0$
		
		$M[1..n]\gets Z$ // $a_0b_0$
		
		$M[mid+1..]\gets M[mid+1..] \oplus Y \ominus U \ominus Z$ // $+[(a_1b_0+a_0b_1)\ll\text{(left shift) } n/2]$
		
		$M[2mid+1..]\gets M[2mid+1..] \oplus U$ // $+[a_1b_1\ll n]$
		
		\Return{$M$}
		
	}
	\caption{Binary Multiplication (Karatsuba's Multiplication Algorithm)}
\end{algorithm}

\textbf{Time Complexity:} $T(n) = 3T(n/2) + n\implies T(n) = \Theta(n^{\log_2 3}) = \Theta(n^{1.585\cdots})$

For recent research, see: \href{https://annals.math.princeton.edu/2021/193-2/p04}{Integer Multiplication in $O(n\log n)$ Time (David Harvey \& Joris van der Hoeven, 2021)}

\subsection{Matrix Multiplication}

$$
\left[
\begin{matrix}
	c_{11} & c_{12} & \cdots & c_{1n}\\
	c_{21} & c_{22} & \cdots & c_{2n}\\
	\cdots & \cdots & \cdots & \cdots\\
	c_{n1} & c_{n2} & \cdots & c_{nn}
\end{matrix}
\right]
=
\left[
\begin{matrix}
	a_{11} & a_{12} & \cdots & a_{1n}\\
	a_{21} & a_{22} & \cdots & a_{2n}\\
	\cdots & \cdots & \cdots & \cdots\\
	a_{n1} & a_{n2} & \cdots & a_{nn}
\end{matrix}
\right]
\left[
\begin{matrix}
	b_{11} & b_{12} & \cdots & b_{1n}\\
	b_{21} & b_{22} & \cdots & b_{2n}\\
	\cdots & \cdots & \cdots & \cdots\\
	b_{n1} & b_{n2} & \cdots & b_{nn}
\end{matrix}
\right]\quad
c_{ij} = \sum_{k=1}^n a_{ik} b_{kj}
$$

\textbf{Brute Force Method:} $\Theta (n^3)$ time.

\subsubsection{A D\&C Solution to Matrix Multiplication}

$$
\left[
\begin{matrix}
	C_{11} & C_{12}\\
	C_{21} & C_{22}
\end{matrix}
\right]
=
\left[
\begin{matrix}
	B_{11} & B_{12}\\
	B_{21} & B_{22}
\end{matrix}
\right]
\left[
\begin{matrix}
	A_{11} & A_{12}\\
	A_{21} & A_{22}
\end{matrix}
\right]\quad
\begin{cases}
	C_{11} = (A_{11}\times B_{11}) + (A_{12}\times B_{21})\\
	C_{12} = (A_{11}\times B_{12}) + (A_{12}\times B_{22})\\
	C_{21} = (A_{21}\times B_{11}) + (A_{22}\times B_{21})\\
	C_{22} = (A_{21}\times B_{12}) + (A_{22}\times B_{22})
\end{cases}
$$

\textbf{Recursion:} $T(n) = 8T(n/2) + O(n^2) \implies T(n) = O(n^3)$

\newpage

\subsubsection{Strassen's Matrix Multiplication Algorithm}

\textbf{Idea:} Muliply 2-by-2 block matrices with only 7 multiplications

$$
\left[
\begin{matrix}
	C_{11} & C_{12}\\
	C_{21} & C_{22}
\end{matrix}
\right]
=
\left[
\begin{matrix}
	B_{11} & B_{12}\\
	B_{21} & B_{22}
\end{matrix}
\right]
\left[
\begin{matrix}
	A_{11} & A_{12}\\
	A_{21} & A_{22}
\end{matrix}
\right]
$$
$$
\begin{cases}
	P_1 = A_{11} \times (B_{12}-B_{22})\\
	P_2 = (A_{11}+A_{12}) \times B_{22}\\
	P_3 = (A_{21}+A_{22}) \times B_{11}\\
	P_4 = A_{22} \times (B_{21}-B_{11})\\
	P_5 = (A_{11}+A_{12}) \times (B_{11}+B_{22})\\
	P_6 = (A_{12}-A_{22}) \times (B_{21}+B_{22})\\
	P_7 = (A_{11}-A_{21}) \times (B_{11}+B_{12})
\end{cases}
\quad
\begin{cases}
	C_{11} = P_5+P_4-P_2+P_6\\
	C_{12} = P_1+P_2\\
	C_{21} = P_3+P_4\\
	C_{22} = P_5+P_1-P_3-P_7
\end{cases}
$$

\textbf{Recursion:} $T(n) = 7T(n/2) + n^2 \implies T(n) = \Theta(n^{\log_2 7}) = \Theta(n^{2.807\cdots})$

For recent research, see: \href{https://arxiv.org/abs/1401.7714}{Powers of Tensors and Fast Matrix Multiplication (Le Gall, 2014)}

\subsection{Master Theorem}








% \begin{comment}

\newpage

\section*{Homework 1}

\textbf{Name: LIN, Xuanyu, SID: 20838295, Email Address: xlinbf@connect.ust.hk}

\begin{Problem}
	
	For each pair of expressions $(A, B)$ below, indicate whether $A$
	is $O, \Omega, \text{or } \Theta$ of B. List all applicable relations. No explanation is needed.
	
	\noindent (a) $A = n^3-100n$, $B = n^2+50n$
	
	\noindent (b) $A = \log_2(n^2)$, $B = \log_{2.7}(n^4)$
	
	\noindent (c) $A = 10^{10000}$, $B = \frac{n}{10^{10000}}$
	
	\noindent (d) $A = 2^{n\log n}$, $B = n^{10}+8n^2$
	
	\noindent (e) $A = 2^n$, $B = 2^{n+\log n}$
	
	\noindent (f) $A = 3^{3n}$, $B = 3^{2n}$
	
	\noindent (g) $A = (\sqrt{2})^{\log n}$, $B = \sqrt{\log n}$
	
\end{Problem}

\textbf{Solution.}
	
	(a) $A = \Omega(B)$
	
	(b) $A = O(B), A = \Omega(B), A = \Theta(B)$
	
	(c) $A = O(B)$
	
	(d) $A = \Omega(B)$
	
	(e) $A = O(B)$
	
	(f) $A = \Omega(B)$
	
	(g) $A = \Omega(B)$

\newpage

\begin{Problem}
	
	Derive asymptotic upper bounds for T(n) in the following recurrences. Make your bounds as tight as possible. You may assume that $n$ is a power of 2 for (a), $n$ is a power of 4 for (b), and $\sqrt{n}$ is always an integer for (c).
	
	\noindent (a) $T(1) = 1$; $T(n) = 4T(n/2) + n^2$ for $n>1$.
	
	\noindent (b) $T(1) = 1$; $T(n) = 16T(n/4) + n$ for $n>1$.
	
	\noindent (c) $T(2) = 1$; $T(n) = T(\sqrt{n}) + 1$ for $n>1$.
	
\end{Problem}

\textbf{Solution.}

(a)
$$
\begin{aligned}
	T(n) &= 4T(n/2) + n^2 = 4[4T(n/4) + (n/2)^2] + n^2 = 4\{4[4T(n/8) + (n/4)^2] + (n/2)^2\} + n^2\\
	&= 4\{4\{4\{\cdots [4T(1) + 2^2] + 4^2\} + \cdots + (n/4)^2\} + (n/2)^2\} + n^2\\
	&= 4^{\log_2 n} + 4^{\log_2 n - 1} \times 2^2 + 4^{\log_2 n - 2} \times 4^2 + \cdots + 4^{1} \times (n/2)^2 + n^2\\
	&= n^2 + \frac{n^2}{4} \times 2^2 + \frac{n^2}{4^2} \times 4^2 + \cdots + 4 \times (n/2)^2 + n^2\\
	&= n^2 (\log_2 n + 1) = O(n^2\log n)
\end{aligned}
$$

(b)
$$
\begin{aligned}
	T(n) &= 16T(n/4) + n = 16[16T(n/4^2) + n/4] + n = 16\{16[16T(n/4^3) + n/4^2] + n/4\} + n\\
	&= 16\{16\{16\{\cdots [16T(1) + 4] + 4^2\} + \cdots + n/4^2\} + n/4\} + n\\
	&= 16^{\log_4 n} + 16^{\log_4 n - 1} \times 4 + 16^{\log_4 n - 2} \times 4^2 + \cdots + 16^{1} \times n/4 + n\\
	&= n^2 + \frac{n^2}{4} + \frac{n^2}{4^2} + \cdots + 4n + n\\
	&= \frac{n-4n^2}{1-4} = \frac{4}{3} n^2 -\frac{1}{3} n = O(n^2)
\end{aligned}
$$

(c)
$$
\begin{aligned}
	T(n) &= T(\sqrt{n}) + 1 = T(n^{1/2^2}) + 2 = T(n^{1/2^3}) + 3 = \cdots = T(2) + \log_2 n - 1 = O(\log_2 n)
\end{aligned}
$$

\newpage

\begin{Problem}
	
	\noindent (a) Describe a recursive algorithm that returns a list of all possible $n\times n$ binary arrays where $n$ is a positive input integer. An array is binary if each of its entry is either 0 or 1. You can either describe your algorithm in text or in a documented pseudocode. Make sure that your algorithm is recursive. Make sure that your description is understandable.
	
	\noindent (b) Write down the recurrence for the running time of your
	recursive algorithm in (a) with the boundary condition(s). Explain your notations. Solve your recurrence from scratch to obtain the
	the running time of your algorithm.
	
\end{Problem}

\textbf{Solution.}

(a)
\begin{algorithm}
	\SetAlgoLined
	\SetKwFunction{AllBinaryArrays}{AllBinaryArrays}
	\AllBinaryArrays{$n$}{
		
	}

	\underline{First Call:} \AllBinaryArrays{$n$}

	\caption{All $n\times n$ Binary Arrays}
\end{algorithm}

(b) \textbf{Recurrence:} $T(n) = $

\newpage

\begin{Problem}
	
	Let $A[1..n]$ be an array of $n$ elements. One can compare in $O(1)$ time two elements of $A$ to see if they are equal or not; however,
	the order relations $<$ and $>$ do not make sense. That is, one can check whether $A[i] = A[j]$ in $O(1)$ time, but the relations $A[i] < A[j]$ and $A[i] > A[j]$ are undefined and cannot be determined.
	
	\noindent In the tutorial you developed an $O(n\log n)$-time divide-and-conquer algorithm for finding a majority element of $A$ if one exists. In this assignment you need to generalize this problem.
	
	\noindent Let $k\in [1..n]$ be a fixed integer. An element of $A[1..n]$ is a k-major element if its number of occurrences in A is greater than $n/k$. For example, if $n = 30$, then a 10-major element should occur greater than 3 times (i.e., at least 4 times). Note that it is possible that no k-major exists for a particular k; it is also possible that there are multiple k-major elements for a particular k.
	
	\noindent This problem concerns with designing a divide-and-conquer algorithm for finding \textbf{all} 10-major elements in $A[1..n]$ in $O(n\log n)$ time; if there is no 10-major element, report so. Answer the following questions.
	
	(a) What is the maximum number of 10-major elements in
	$A[1..n]$? Explain.
	
	(b) Design a divide-and-conquer algorithm that finds all 10-major elements in $A[1..n]$ in $O(n\log n)$ time; if there is no 10-major element, your algorithm should report so. Recall that one can check whether $A[i] = A[j]$ in $O(1)$ time, but the relations $A[i] < A[j]$ and $A[i] > A[j]$ are undefined and cannot be computed.
	
	\noindent \textbf{Write your algorithm in documented pseudocode. Also, explain in text what your pseudocode does. Explain the correctness of your algorithm.}
	
	\noindent Since your algorithm uses the divide-and-conquer principle, it should
	be recursive in nature. That is, it should work on $A[1..n]$ in the
	first call to return all 10-major elements of $A[1..n]$, and in subsequent recursive calls, it may recurse on many subarrays $A[p..q]$ for some $p, q\in [1..n]$ to return all 10-major elements of $A[p..q]$
	
	\noindent Given a particular subarray $A[p..q]$, a 10-major element of $A[p..q]$ is not necessarily a 10-major element of $A[1..n]$. Conversely, a 10-major element of $A[1..n]$ is not necessarily a 10-major element of $A[p..q]$.
	
	(c) Derive a recurrence relation that describes the running time $T(n)$ of your algorithm. Explain your reasoning. State the boundary condition(s).
	
	(d) Solve your recurrence \textbf{from scratch} to show that $T(n) = O(n\log n)$.
	
\end{Problem}

\textbf{Solution.}

\newpage

\section*{Homework 2}

\textbf{Name: LIN, Xuanyu, SID: 20838295, Email Address: xlinbf@connect.ust.hk}

\begin{Problem}
	
\end{Problem}

\textbf{Solution.}

\newpage

\begin{Problem}
	
\end{Problem}

\textbf{Solution.}

\newpage

\begin{Problem}
	
\end{Problem}

\textbf{Solution.}

% \end{comment}

\end{document}